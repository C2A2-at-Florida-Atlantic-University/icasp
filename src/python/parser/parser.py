"""
This script performs parsing of the POWDER dataset files to prepare them for
further experimentation. 

How to run this script?

1. Download the dataset: https://renew-wireless.org/dataset-aoa.html

    Note: no need to download all files. Download the ones specified
    in the DATASETS variable.

2. Configure DIR_SOURCE and DIR_TARGET variables to match your setup.

    DIR_SOURCE is a path to all downloaded datasets. Ensure that your files
    are saved in the following fashion: 

        runAxB
            trace-uplink-2021.....
        runAxB
            trace-uplink-2021.....

        Where A represents horizontal position of the client emitter (1-8),
        B represents vertical position of the client emitter (1-10).

    DIR_TARGET is a path to files which will be generated by this script. 
    By defaut, it is configured to be the 'data' folder in this repository.

3. Install necessary dependencies (numpy, h5py, scipy) and run the script:

    python3 parser.py

4. Continue the experiment in the Matlab section of the repository.
"""

import h5py
import matplotlib.pyplot as plt
import numpy as np
import find_lts
import scipy.io

EMITTER_IDX_REFERENCE = 1
EMITTER_IDX_CLIENT = 0

# DIR = '/Users/stepanmazokha/Documents/Mobintel/datasets/POWDER/aoa_powder_chamber'
DIR_SOURCE = '/Volumes/Disk/mMIMO'
DIR_TARGET = '../../../data'

FRAME_START_IDX = 100
FRAME_COUNT = 20

DATASETS = [
    ['run1x1', 'trace-uplink-2021-12-3-16-28-51_1x48x2_0_47.hdf5'],
    ['run2x1', 'trace-uplink-2021-12-3-17-43-58_1x48x2_0_47.hdf5'],
    ['run3x1', 'trace-uplink-2021-12-3-19-17-46_1x48x2_0_47.hdf5'],
    ['run4x1', 'trace-uplink-2021-12-3-20-41-34_1x48x2_0_47.hdf5'],
    ['run5x1', 'trace-uplink-2021-12-4-9-13-36_1x48x2_0_47.hdf5'],
    ['run6x1', 'trace-uplink-2021-12-4-10-32-35_1x48x2_0_47.hdf5'],
    ['run7x1', 'trace-uplink-2021-12-4-11-38-27_1x48x2_0_47.hdf5'],
    ['run8x1', 'trace-uplink-2021-12-4-12-49-47_1x48x2_0_47.hdf5']]

def load_dataset(path, name, frame_start, frame_count, verbose):
    """
    Loads a POWDER dataset and returns a subset of available IQ samples.

    :path: Path to the directory wtih a file.
    :name: Name of the dataset file.
    :frame_start: Defines from which sample to statt retrieval.
    :frame_count: Defines how many IQ samples to retrieve.
    """

    dataset_file = path + '/' + name[0] + '/' + name[1]

    print('Loading data for %s' % dataset_file)

    h5file = h5py.File(dataset_file, 'r')['Data']

    # Load the pilot IQ samples
    pilots = h5file['Pilot_Samples']
    
    # Extract metadata
    client_coord = h5file.attrs['CLIENT_COORDINATES']
    ref_coord = h5file.attrs['REFERENCE_COORDINATES']
    mimo_coord = h5file.attrs['MIMO_COORDINATES']
    samps_per_slot = int(h5file.attrs['SLOT_SAMP_LEN'])
    # pilot_seq = h5file.attrs['OFDM_PILOT']

    # Convert raw IQ samples into complex values
    matlab_package = prepare_iq_samples(pilots, frame_start, frame_count, samps_per_slot)

    # Find LTS1 start indexes
    reference_lts_positions, client_lts_positions = prepare_lts_starts(pilots, frame_start, frame_count, samps_per_slot, verbose)
    matlab_package['reference_lts_positions'] = reference_lts_positions
    matlab_package['client_lts_positions'] = client_lts_positions

    # Calculate ground truth angles
    azimuth_client, azimuth_reference, elevation_client, elevation_reference = prepare_angles(mimo_coord, client_coord, ref_coord, verbose)
    matlab_package['azimuth_client'] = azimuth_client
    matlab_package['azimuth_reference'] = azimuth_reference
    matlab_package['elevation_client'] = elevation_client
    matlab_package['elevation_reference'] = elevation_reference

    matlab_package['client_coord'] = client_coord
    matlab_package['ref_coord'] = ref_coord
    matlab_package['mimo_coord'] = mimo_coord

    return matlab_package

def prepare_angles(mimo_coord, client_coord, ref_coord, verbose):
    """
    Performs calculation of ground truth DoA angles using dataset metadata.

    :mimo_coord: Coordinates of the MIMO receiver.
    :client_coord: Coordinates of the client emitter.
    :ref_coord: Coordinates of the reference emitter.
    """

    if verbose:
        print('=========== CALCULATING DATASET COORDINATES ===========')
        print('MIMO: %s' % mimo_coord)
        print('Client: %s' % client_coord)
        print('Reference: %s' % ref_coord)

        plt.plot(mimo_coord[0], mimo_coord[1], 'o', c='black', label = 'receiver')
        plt.plot(client_coord[0], client_coord[1], 'o', c='red', label = 'emitter')
        plt.plot(ref_coord[0], ref_coord[1], 'o', c='green', label = 'reference')
        plt.legend()
        plt.title('Client, Reference emitters & Receiver: in XOY plane')

    # Find azimuth (horizontal plane angle) between receiver and reference
    vector_client = client_coord[0:3] - mimo_coord[0:3]
    vector_reference = ref_coord[0:3] - mimo_coord[0:3]

    # Calculate angles
    azimuth_client = np.degrees(np.arctan(vector_client[0]/vector_client[1]))
    azimuth_reference = np.degrees(np.arctan(vector_reference[0]/vector_reference[1]))
    elevation_client = np.degrees(np.arctan(vector_client[2]/vector_client[1]))
    elevation_reference = np.degrees(np.arctan(vector_reference[2]/vector_reference[1]))

    if verbose:
        print('=================================')
        print('Client Azimuth: %.2f degrees' % np.degrees(np.arctan(vector_client[0]/vector_client[1])))
        print('Reference Azimuth: %.2f degrees' % np.degrees(np.arctan(vector_reference[0]/vector_reference[1])))
        print('=================================')
        print('Client Elevation: %.2f degrees' % np.degrees(np.arctan(vector_client[2]/vector_client[1])))
        print('Reference Elevation: %.2f degrees' % np.degrees(np.arctan(vector_reference[2]/vector_reference[1])))

    return azimuth_client, azimuth_reference, elevation_client, elevation_reference

def prepare_iq_samples(pilots, frame_start, frame_count, samps_per_slot):
    """
    Performs conversion of IQ samples from raw format into complex numbers.

    :pilots: IQ samples to convert.
    :frame_start: Frame from which to start reading the data.
    :frame_count: Number of frames to read.
    :samps_per_slot: Number of sampls available per each frame.
    """

    matlab_package = {}

    # Store samples from reference emitter
    for frame_idx in range(frame_start, frame_start + frame_count):
        I = pilots[frame_idx, 0, 1, :, 0:samps_per_slot * 2:2] / 2 ** 15
        Q = pilots[frame_idx, 0, 1, :, 1:samps_per_slot * 2:2] / 2 ** 15
        IQ = I + (Q * 1j)

        matlab_package['reference_frame_' + str(frame_idx)] = IQ

    # Store samples from client emitter
    for frame_idx in range(frame_start, frame_start + frame_count):
        I = pilots[frame_idx, 0, 0, :, 0:samps_per_slot * 2:2] / 2 ** 15
        Q = pilots[frame_idx, 0, 0, :, 1:samps_per_slot * 2:2] / 2 ** 15
        IQ = I + (Q * 1j)

        matlab_package['client_frame_' + str(frame_idx)] = IQ

    return matlab_package

def prepare_frame_lts_start(pilots, frame_idx, emitter_idx, samps_per_slot, verbose):
    # Initiate array that will store indexes for frame peaks
    frame_peaks = np.zeros((48))

    for ant in range(48):
        I = pilots[frame_idx, 0, emitter_idx, ant, 0:samps_per_slot * 2:2] / 2 ** 15
        Q = pilots[frame_idx, 0, emitter_idx, ant, 1:samps_per_slot * 2:2] / 2 ** 15
        IQ = I + (Q * 1j)

        best_pk, lts_pks, lts_corr = find_lts.find_lts(IQ, thresh=0.8, flip=True)

        # Store index of the sample from which LTS1 begins
        try:
            frame_peaks[ant] = lts_pks[0] if len(lts_pks) > 0 else -1
        except:
            frame_peaks[ant] = -1
            if ant % 2 != 0 and verbose:
                print('Failed to find LTS. Frame #%s Antenna #%s Emitter #%s' % (frame_idx, ant, emitter_idx))

    return frame_peaks

def prepare_lts_starts(pilots, frame_start, frame_count, samps_per_slot, verbose):
    reference_lts_positions = np.zeros((20, 48))
    client_lts_positions = np.zeros((20, 48))

    for frame_idx in range(frame_start, frame_start + frame_count):    
        reference_lts_positions[frame_idx-100, :] = prepare_frame_lts_start(pilots, frame_idx, EMITTER_IDX_REFERENCE, samps_per_slot, verbose)
        client_lts_positions[frame_idx-100, :] = prepare_frame_lts_start(pilots, frame_idx, EMITTER_IDX_CLIENT, samps_per_slot, verbose)

    return reference_lts_positions, client_lts_positions

def save_matlab_file(path, filename, payload):
    scipy.io.savemat(path + '/' + filename + '.mat', mdict=payload)

if __name__ == '__main__':
    """
    Perform parsing of provided POWDER dataset files.
    """
    for i in range(len(DATASETS)):
        dataset = DATASETS[i]
        matlab_package = load_dataset(DIR_SOURCE, dataset, FRAME_START_IDX, FRAME_COUNT, verbose=False)
        save_matlab_file(DIR_TARGET, dataset[0], matlab_package)